# Resume

Wanted 이력서에서 나올만한 기술 질문들을 정리한 페이지. (2025-05-05)


## 리팩토링 
 

레플리의 프로젝트에는 흔히 말하는 아키텍처라는게 없었습니다. ViewController에 API 호출, DB 조회, 타입 비교 등의 로직이 모두 작성되어 있었고 이는 당연히 가독성을 해치고 중복 코드를 굉장히 많이 만들어내는 방식이었습니다. Rx를 사용하기는 했지만 서로 다른 뷰컨트롤러 간에 발생하는 모든 이벤트를 전역적으로 전파하기 위해 사용하고 있어서 디버깅하기가 매우 어려웠습니다. 

SwiftUI에서 TCA를 적용하기 위해 장기간 학습을 한 상태였고, point-free에서 문서나 자료를 보니 UIKit에서도 충분히 사용할 수 있다고 판단하여 리팩토링을 진행했습니다. 

## 채팅 기능 개선 

채팅 기능에 삭제 및 수정 기능을 추가하는 작업을 맡았습니다. 데이터 변경 자체는 문제가 없었지만, 테이블 뷰 업데이트 방식에 문제가 있었습니다. reloadData()를 사용하면 스크롤 위치가 예상치 못한 곳으로 이동하는데, 이는 현재 스크롤된 indexPath를 기준으로 뷰가 다시 계산되기 때문입니다.

그런데 전체 기능이 전부 reloadData() 기반으로 구현되어 있었습니다. 채팅 기능은 기본적으로 양방향 데이터 추가가 가능해야 하고, 위로 스크롤 시 추가 로딩이 있어야 자연스러운데, 이런 구조로 구현되어 있는 것이 의아했습니다.

기존 코드를 살펴보니, 모든 채팅 데이터를 Core Data에 저장하고, 채팅방에 진입할 때 전체 데이터를 한 번에 불러오는 구조였습니다. 즉, 페이징이 전혀 적용되지 않은 상황이었습니다. 이제 수정 및 삭제 기능까지 추가되다 보니, 멀티 디바이스 사용 시 데이터 불일치 문제가 생길 수 있다고 판단했습니다.

그러나 서버는 변경된 데이터만 가져오는 API를 제공하지 않고 있었고, 로컬 저장소만으로는 데이터 정합성을 보장하기 어렵다고 판단했습니다. 이에 다른 개발자와 논의 후, 로컬 저장을 제거하기로 결정했습니다.

이후에는 테이블 뷰에 TCA(The Composable Architecture)를 적용하여 전체 구조를 리팩토링했고, 요구받은 기능들도 모두 구현했습니다.

개발을 마치고 회고를 진행하면서, 이벤트별로 테이블 뷰 갱신 방식을 별도 프로퍼티로 관리한 방식이 적절했는지에 대한 의문이 생겼습니다. 그래서 Rx의 구현 방식을 찾아봤는데, Rx는 Paul Heckel의 Diffing 알고리즘을 기반으로 테이블 뷰를 업데이트하고 있었습니다. 만약 시간이 더 있었다면, Rx처럼 Diffing을 활용해 table view를 래핑하거나, 아니면 차라리 테이블 뷰가 필요한 상황에서는 Rx 자체를 사용하는 방식이 더 나았을 수도 있겠다는 생각이 들었습니다. 

## 페이징 개선 

예를 들어, 챗봇에 좋아요를 누르거나 채팅을 보낼 때, 로컬에 있는 리스트에도 그 변화가 반영되어야 했습니다.
좋아요를 누른 챗봇은 좋아요 리스트에 추가되어야 했고, 채팅을 보낸 챗봇은 채팅 리스트의 최상단에 위치해야 했습니다.

하지만 기존 구조는 전체 리스트를 처음부터 재귀적으로 다시 가져오는 방식으로 구현되어 있었고,
특정 상황에서 이 로직이 과도하게 호출되어 서버에 부하를 주고 있다는 공유를 받았습니다.

이에 저는 리스트 변경 사항을 별도의 API 호출 없이, 로컬에서만 처리할 수 있도록 개선했습니다.
TCA의 Sharing 기능을 활용하여, 서비스 전역에서 사용하는 리스트들을 공통된 상태로 관리할 수 있도록 했고,
상황에 따라 쉽게 정렬, 추가, 삭제할 수 있는 구조로 리팩토링했습니다.

또, 챗봇의 이름같은 경우는 단순히 사전 정렬이 아닙니다. 한글이 우선순위가 제일 높고, 그 다음은 영어, 그 다음이 숫자와 특수문자 순입니다. 아스키 코드 순으로 정렬을 해보니 서버에서 주는 순서와 다르다는 것을 찾았습니다. 그래서 서버의 로직을 공유받아서 구현을 했고, 테스트 코드를 작성해 좋아요, 즐겨찾기, 이름의 상태에 따라서 정렬이 어떻게 되는지 확인 했습니다. 정확히 하려면 서버와 공통된 케이스를 만들어서 확인을 했어야할거 같은데 서로의 업무가 바쁘다보니 제 쪽에서만 확인을 했었습니다. 

API 호출에 대한 성능은 정밀하게 측정하지는 않았지만 좋아요나 채팅 등의 이벤트가 발생할 때마다 생기는 재귀적은 호출을 줄였으니 성능적으로도 충분한 개선이 됐을 것입니다. 

## 테스트 

모든 기술에는 명확한 목적이 있어야 한다고 생각합니다. 테스트 역시 마찬가지고, 저는 테스트를 세 가지 목적으로 작성합니다.

    1.    구현 세부 사항에 대한 문서화
    2.    사이드 이펙트 방지
    3.    카운터 케이스 도출

예를 들어, 레플리에서는 채팅 시 하트가 소모되었고, 하트는 타이머를 통해 충전되는 구조였습니다.
이 타이머 기능에 문제가 있어서 수정하던 중, 디자이너 분께서 타이머 실행 버튼을 눌렀을 때 이전에 작동했던 시간으로 다시 시작되어야 한다고 말씀해주셨습니다.

이 내용은 피그마나 노션 등 문서에는 명시되어 있지 않았고, 주석으로 남겨도 놓치기 쉬운 디테일이라고 판단했습니다.
그래서 이러한 세부 동작은 테스트 코드로 명시적으로 문서화했습니다.

지금 당장은 테스트의 필요성이 체감되지 않을 수 있지만,
시간이 지난 뒤 저 자신이나 다른 개발자가 봤을 때도 동작 의도를 정확히 이해할 수 있기 때문에,
장기적으로 프로젝트의 품질 향상에 기여한다고 믿고 있습니다.

⸻

사이드 이펙트 방지를 위한 테스트는 많을수록 좋지만, 현실적으로 모든 경우를 커버하긴 어렵기 때문에,
저는 개발 중 마주친 버그에 우선 대응하는 방식으로 작성했습니다.
레플리에서는 해당 사례가 없었지만, 바우디움에서 텍스트 에디터를 개발할 때에는 많이 작성했습니다.

⸻

카운터 케이스 테스트 역시 바우디움에서 자주 작성했습니다.
데이터를 Serialize/Deserialize하거나, XML을 파싱할 일이 많았는데,
예를 들어 동일한 태그가 반복될 경우 어떻게 동작할지를 가정하여 테스트를 작성했습니다.

UI 테스트의 경우에는 하드웨어 이벤트가 필요하거나 뷰들의 기하학적 위치를 확인해야하는 경우에 사용했습니다. 

## 재사용성 향상 

레플리는 이메일 및 전화번호를 이용한 비밀번호 변경, 로그인, 개인정보 변경 기능을 제공했습니다. 해당 기능들은 서로 유사한 뷰 구조를 갖고 있었지만, 각각 별도의 뷰컨트롤러로 구현되어 있었고, 복사-붙여넣기 방식으로 중복된 코드가 반복되고 있었습니다.

이 문제는 두 가지 형태의 의존성 주입을 통해 해결할 수 있었습니다.
첫 번째는 문자열 형식 검증에 대한 의존성 주입입니다. 이메일이나 전화번호 형식 등을 검증하는 로직을 추상화한 뒤, 필요한 형식에 따라 적절한 검증 타입을 주입함으로써 유연하게 처리할 수 있었습니다.
두 번째는 API 호출에 대한 추상화입니다. 문자열 형식 검증 후 사용자의 이메일 또는 전화번호로 인증번호를 요청해야 했기 때문에, 이 로직 또한 인터페이스로 추상화하여 주입 가능하도록 구성했습니다.

이러한 구조를 통해 기존에 5개로 나뉘어 있던 뷰컨트롤러를 하나의 재사용 가능한 뷰컨트롤러로 통합할 수 있었습니다.

## 텍스트 에디터

fecit!의 핵심은 버전 관리가 가능한 문서입니다. 쉽게 말해, 개발자가 아니더라도 Git처럼 문서를 버전 관리할 수 있고, UI는 노션과 유사한 형식으로 제공됩니다.

하지만 이러한 기능을 모바일에서 제공하는 서비스는 드뭅니다. GPT와 같은 생성형 AI로 구현할 수 있는 성격의 기능도 아니었고, 유사한 기능을 검색을 통해 참고하기도 어려웠습니다. 그래서 직접 텍스트 에디터를 개발하며 수많은 문제를 마주해야 했습니다.

예를 들어, 한글은 조합형 언어이기 때문에 자음과 모음이 입력되며 기존 문자가 실시간으로 대체됩니다. 그런데 텍스트 중간에서 NSAttributedString의 Attribute가 변경되면, 이 조합이 깨지고 자음과 모음이 분리된 상태로 입력되는 문제가 발생했습니다.

또 다른 문제는 Fragment 처리 방식이었습니다. 내부적으로 TextEditor는 줄바꿈(\n)을 기준으로 텍스트를 Fragment 단위로 나눕니다. 이때 중간에 줄바꿈이 생기면 새로운 Fragment가 잘 생성되지만, 마지막 줄에서 줄바꿈이 추가되면 새로운 Fragment가 생성되지 않습니다. 하지만 저희 서비스는 마지막 줄이 비어 있어도 리스트 마커 등을 보여줘야 했기 때문에, 이 문제가 UX에 큰 영향을 주었습니다.

참고할 수 있는 자료가 거의 없었기에, 기능 하나를 추가할 때도 많은 사이드 이펙트가 발생했고 이를 해결하기 위해 테스트를 철저히 작성했습니다.

문자열을 서버에서 받아와 XML로 파싱하고, 이를 AttributedString으로 직렬화한 뒤, 다시 UI에 렌더링하는 전 과정에서 발생할 수 있는 케이스를 고려해 Unit Test, UI Test를 적절히 활용하며 안정성을 높였습니다.


