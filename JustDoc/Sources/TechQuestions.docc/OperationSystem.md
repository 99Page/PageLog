# Operation System

운영 체제 관련 내용을 정리한 문서 

## 목차

* [프로세스](#프로세스)
* [페이징](#페이징)
* [페이지 교체](#페이지-교체-알고리즘)
* [스케쥴링](#스케쥴링)
* [동시성](#동시성)

## 프로세스

1. 프로세스와 스레드의 차이점 

프로세스란 실행 중인 프로그램을 뜻한다. 메모리에 코드-데이터-스택-힙 영역을 갖는다. 컨텍스트 스위칭 중에 비교가 크다. 
쓰레드는 경량화된 프로세스다. 코드-데이터-힙 영역을 공유하며 컨텍스트 스위칭 영역을 아낄 수 있다. 스택에는 지역 변수, 함수 호출 스택 등이 쌓이니 공유하지 않는다. 

2. 멀티프로세싱, 멀티스레드의 장단점 

멀티프로세싱은 안정성이 높지만 컨텍스트 스위칭 비용이 크다.
멀티 스레딩은 성능은 좋지만 동기화 문제가 발생할 수 있다. 


## 페이징

1. 페이징이란? 

>키워드: 가상 주소, 물리 주소, 페이지 테이블, 내부 단편화, 외부 단편화


물리 메모리와 가상 메모리를 관리하는 기법으로, 프로세스가 연속된 물리적 공간에 있지 않아도 실행할 수 있고 프로세스 별 독자적인 메모리 공간을 제공할 수 있다.

|프로그램|가상주소|실제 주소|
|---|---|---|
|A|0x1000|0x2000|
|B|0x1000|0x3000

두 프로그램은 서로 같은 가상주소를 갖지만, 실제 주소는 다르다. **페이지 테이블**이 가상 주소를 물리 주소로 변환해주는 매핑 정보를 담고 있다. 

외부 단편화는 해결되지만 내부 단편화 문제가 남는다. 

|메모리|프로세스 종류|사용 크기|
|---|---|---|
|4KB|A|4KB|
|4KB|A|2KB|
|4KB|B|4KB|
|4KB|A|4KB

위 표에서 프로세스 A가 연속적이지 않게있다. 하지만 페이지 테이블을 통한 매핑으로 연속된것처럼 이용할 수 있다. 이를 통해 외부 단편화 문제는 해결이 된다.

하지만 세번째 메모리 공간에서 A가 사용하는 메모리의 크기는 2KB다. 남는 메모리 공간이 존재하게 되는데, 이게 내부 단편화 문제다. 

## 페이지 교체 알고리즘

1. FIFO

가장 먼저 들어온 페이지 교체 

2. LRU 

가장 오랫동안 사용되지 않는 페이지를 교체

3. OPT

앞으로 가장 늦게 사용될 페이지를 교체. 하지만 늦게 사용될 것을 추측하기가 어려움

## 스케쥴링

### Non-preemptive 

CPU를 점유중인 다른 프로세스의 우선순위를 뺏지 않는 방법

1. FCFS

First come, First serverd의 약자. 먼저 들어온 순서대로 처리한다. 

convoy effect가 발생할 수 있다. 실행 시간이 짧은 프로세스가 큐에서 오래 기다려야한다.

2. SJF

Shortest Job First. 실행 시간이 짧은 프로세스부터 처리한다. 실행 시간이 긴 프로세스가 실행되지 않는, Starvation 상태가 될 수 있다. 

3. 우선순위 

각 프로세스 별로 우선순위를 부여한다. 중요한 작업을 빠르게 처리할 수 있지만 우선순위가 낮은 경우 기아 상태가 된다.

### Preemptive 

CPU를 점유중인 다른 프로세스를 뺏는 방법 

1. Round robin 

현대 운영체제의 대부분 스케줄링 방법. 각 프로세스가 동일한 시간(Time quantum)으로 실행되고, 그 시간에 끝나지 않으면 큐로 넘긴다. 

프로세스의 점유 시간이 공정하고, 응답 시간을 예측할 수 있지만 

할당 시간이 크면 FCFS와 유사해지고, 작으면 컨텍스트 스위칭 비용이 커진다. 

2. Shortest Remaining Time First

실행 중인 것보다 더 짧은 프로세스가 있으면 그거부터 실행하는 방식. 

프로세스의 실행 시간 예측이 어렵다.

3. Multilevel Queue Scheduling 

프로세스의 우선순위를 다양한 큐에 분류하고, 각 큐에는 다른 알고리즘을 적용하는 방식. 

각 프로세스 특성에 맞는 알고리즘을 선택할 수 있지만 구현이 어렵고 특정 큐는 기아 상태가 될 수 있다. 

## 동시성

1. 뮤텍스 

1개의 자원을 보호하는 데 사용하는 이진 동기화 객체 (Locked / Unlocked)

2. 세마포어 

정수 값을 가지며, 자원 개수를 제어하는 동기화 도구 (ex. 3개 자원 → 값: 3부터 시작)

wait()와 signal() 연산으로 동작한다 

3. deadlock이 실행되기 위한 4가지 조건

```
1. 순환 대기
2. Hold and wait: 하나의 자원을 점유한 상태에서 다른 자원 요청 대기
3. 비선점 
4. Mutual exclusion: 하나의 자원을 둘 이상의 프로세스가 사용 불가
```
