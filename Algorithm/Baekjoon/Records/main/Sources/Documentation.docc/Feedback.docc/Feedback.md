# Feedback

알고리즘 풀이를 위한 사고를 정리한 문서 

## Overview

문제를 크게 6가지 상황 방식으로 접근합니다. 

* 시뮬레이션/구현 
* Brute force 
* Greedy 
* Backtracking
* Divide and Conquer 
* Dynamic Programming 

## 백트래킹 

다음 상황에 사용 할 수 있습니다. 

1. 그래프 탐색 문제 
2. 점화식 같은, 재귀적인 문제
3. Divide Conquer를 사용해야할 때. 문제가 자연스럽게 분할되는 상황에서 

### 먼저 고민

항상 `Base case`, `Memoization`을 먼저 고민해야합니다.

`Base case`: 탐색을 그만두기 위한 조건 

`Memoization`: 중복되는 탐색 방지 

언제 방문할 수 있고, 방문후 무엇을 처리해야하는지도 함께 고민합니다. 

### 부적절한 상황 

탐색 순서에 민감한 경우, Backtrakcing으로는 모든 케이스를 확인하지 못합니다.

모든 케이스를 보고 싶은데, 중복은 걸러내고 싶을 때 Backtracking을 사용할 수 있습니다.  

그런데 Backtracking으로 정말 모든 케이스를 확인할 수 있는지는 고민할 필요가 있습니다.  

그 예제가 [게리멘더링 문제](https://www.acmicpc.net/problem/17471) 문제입니다.

Edge를 입력한 순서에 따라서 특정 케이스는 확인하지 못하는 경우가 생깁니다. 

### 케이스 분리

각 케이스를 분리할 수 있는지 고민합니다. 

예를 들어 6개의 주사위를 두명이 나눠서 굴리고 그 합을 비교하는 경우라면

단순히 계산해보면 6^6이지만 각자가 굴릴 수 있는 주사위는 3개씩입니다. 

따라서 개인단위로는 6^3이고, 여기에 이분탐색으로 결과를 비교할 수 있습니다. 

대표적인 문제가 카카오 코테의 [주사위 고르기 문제](https://school.programmers.co.kr/learn/courses/30/lessons/258709) 문제입니다. 
 

### DFS 상태 분리

DFS로 문제를 풀 때는 그 경로만의 unique한 상태를 사용합니다. 

즉, 내부 프로퍼티로 상태를 관리할게 아니라 모든 걸 Parameter로 넘겨주어야합니다. 
