# Feedback

알고리즘 풀이를 위한 사고를 정리한 문서 

## Overview

일반적으로 문제를 아래 방식으로 접근합니다. 

* 시뮬레이션/구현 
* Graph
* Brute force 
* Greedy 
* Backtracking
* Divide and Conquer 
* Dynamic Programming 

## 문제 분석 

문제를 읽고, 익숙한 개념을 찾아 적절한 자료구조나 알고리즘을 사용해야합니다. 문제 해석 후 나만의 언어로 바꾸는 과정이 중요합니다.

* 카운터 케이스를 찾기 쉬운 방식 혹은 카운터 케이스가 나오지 않을 방식으로 접근합니다. 쉬운 방법으로 접근했을 때는, 카운터 케이스를 고려하기가 어렵습니다.

* **관계**가 주어졌는지 확인합니다. 관계가 보일 경우 그래프로 문제를 접근할 수 있습니다. 예를 들어, 순위가 정해진 경우는 indegree, outdegree의 관계를 설정할 수 있고 노드 간의 거리/비용이 주어진 경우도 weight라는 관계를 설정할 수 있습니다.

* 문제에서 배열이 있다면, **정렬** 가능한지 파악합니다. 정렬이 가능하다면 이분 탐색 / 정렬을 활용한 그리디 / 투 포인터 등으로 문제 풀이 방식을 좁힐 수 있습니다. 

* 데이터의 **중복**을 줄여야한다면, Dictionary와 Tree를 사용합니다. 

* 데이터의 **순서**를 파악해야한다면 Heap, 리스트, 위상정렬을 사용합니다. 

* **같은 그룹**을 파악해야하면 Union find를 사용합니다.


## Greedy

그리디는 어떤 문제에서든 적용해볼만한 방법입니다. 

1. 그리디한 접근이 과연 최적의 해를 구할 수 있는지 고민한다. 

따라서 증명이 중요합니다. 

2. 한 문제에는 그리디한 접근이 여러가지 있을 수 있다.

하나의 기준에 대해서 탐욕적인 선택이 틀리더라도 다른 방식의 접근이 존재할 수 있습니다.

### 증명

탐욕적인 선택으로 정답을 도출할 수 있다는 것을 없음을 증명해야합니다.  

각 선택에서 그리디하지 않은 선택을 한 답이, 그리디한 답보다 최적해인 경우가 없음을 보이면 됩니다. 

## 백트래킹 

다음 상황에 사용 할 수 있습니다. 

1. 그래프 탐색 문제 
2. 점화식 같은, 재귀적인 문제
3. Divide Conquer를 사용해야할 때. 문제가 자연스럽게 분할되는 상황에서 

### 생각

항상 `Base case`, `Memoization`을 먼저 고민해야합니다.

`Base case`: 탐색을 그만두기 위한 조건(DFS에서)

`Memoization`: 중복되는 탐색 방지 

언제 방문할 수 있는지

방문후 무엇을 처리해야하는지도 함께 고민합니다. 

### 부적절한 상황 

탐색 순서에 민감한 경우, Backtrakcing으로는 모든 케이스를 확인하지 못합니다.

모든 케이스를 보고 싶은데, 중복은 걸러내고 싶을 때 Backtracking을 사용할 수 있습니다.  

그런데 Backtracking으로 정말 모든 케이스를 확인할 수 있는지는 고민할 필요가 있습니다.  

그 예제가 [게리멘더링 문제](https://www.acmicpc.net/problem/17471) 문제입니다.

Edge를 입력한 순서에 따라서 특정 케이스는 확인하지 못하는 경우가 생깁니다. 

### 케이스 분리

각 케이스를 분리할 수 있는지 고민합니다. 

예를 들어 6개의 주사위를 두명이 나눠서 굴리고 그 합을 비교하는 경우라면

단순히 계산해보면 6^6이지만 각자가 굴릴 수 있는 주사위는 3개씩입니다. 

따라서 개인단위로는 6^3이고, 여기에 이분탐색으로 결과를 비교할 수 있습니다. 

대표적인 문제가 카카오 코테의 [주사위 고르기 문제](https://school.programmers.co.kr/learn/courses/30/lessons/258709) 문제입니다. 
 

### 케이스의 상태

DFS로 문제 풀이 시, 해당 경로만의 정보인지 아니면 전역적으로 관리할 수 있는 정보인지 판단해야 합니다. 

```swift 
visitMap[next.r][next.c] = true
visit(next)
visitMap[next.r][next.c] = false 
```

전역적으로 관리할 수 있는 정보인 경우, 방문을 시작하고 나올 때 상태를 처리해서 call stack의 메모리를 아낄 수 있습니다. 

```swift 
visitMap[next.r][next.c] = true
visit(next, visitMap) 
```

전역적으로 관리하기 어려운 경우는 parameter에 추가해서 다른 경로와 충돌되지 않게 구분해줘야 합니다. 

## Dynamic programming 

DP는 다음 상황에 사용할 수 있습니다.

1. 분할정복처럼, 문제가 부분으로 나누어지면서 중복 계산이 필요해질 때 
2. 배열처럼 특정 순서가 있는 문제를 Step by Step으로 순회하면서 이전 계산 결과가 필요한 경우. 
3. 매번 최적의 결과를 도출하는게 아니고, 최종 결과가 최적일 경우. DFS+BFS를 활용하면서 시간복잡도를 줄일 수 있다.

### Tip 

Memoization을 관리하는 방법은 보통 정해져 있습니다.

1. 현재 값과 이전 배열의 값(혹은 순회 순서상 이전의 값) 중에서 필요한 값을 택한다.

2. 새로 만들어진 값과 기존의 값 중 필요한 값을 택한다.

## Divide and Conquer

문제를 부분으로 나눌 수 있는 경우가 사용합니다.  

예를 들어서 배열이 주어졌을 때 배열을 좌측의 절반 우측의 절반으로 나눠서 해결이 가능한 경우가 있습니다. (Quick sort처럼) 

- 문제에서 점화식을 사용하는 경우

ex) S(n) = S(n-1) + 3 + S(n-1)처럼 구성될 때 재귀 함수를 3등분할 수 있습니다.   

- 배열 패턴이 반복되는 경우

점화식과 유사하다. 예를 들어서 2차원 배열은 같은 패턴의 1차원의 합의 구조인 경우가 있습니다. 
