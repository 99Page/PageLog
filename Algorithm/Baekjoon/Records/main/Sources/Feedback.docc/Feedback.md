# Feedback

알고리즘 풀이를 위한 사고를 정리한 문서 

## Overview

문제를 크게 6가지 상황 방식으로 접근합니다. 

* 시뮬레이션/구현 
* Brute force 
* Greedy 
* Backtracking
* Divide and Conquer 
* Dynamic Programming 

## 문제 설계 

* 카운터 케이스를 찾기 쉬운 방식 혹은 카운터 케이스가 나오지 않을 방식으로 접근하자. 쉬운 방법으로 접근했을 때는, 카운터 케이스를 고려하기가 어렵다. 

## 백트래킹 

다음 상황에 사용 할 수 있습니다. 

1. 그래프 탐색 문제 
2. 점화식 같은, 재귀적인 문제
3. Divide Conquer를 사용해야할 때. 문제가 자연스럽게 분할되는 상황에서 

### 생각

항상 `Base case`, `Memoization`을 먼저 고민해야합니다.

`Base case`: 탐색을 그만두기 위한 조건(DFS에서)

`Memoization`: 중복되는 탐색 방지 

언제 방문할 수 있는지

언제 방문해야하는지 

방문후 무엇을 처리해야하는지도 함께 고민합니다. 

### 부적절한 상황 

탐색 순서에 민감한 경우, Backtrakcing으로는 모든 케이스를 확인하지 못합니다.

모든 케이스를 보고 싶은데, 중복은 걸러내고 싶을 때 Backtracking을 사용할 수 있습니다.  

그런데 Backtracking으로 정말 모든 케이스를 확인할 수 있는지는 고민할 필요가 있습니다.  

그 예제가 [게리멘더링 문제](https://www.acmicpc.net/problem/17471) 문제입니다.

Edge를 입력한 순서에 따라서 특정 케이스는 확인하지 못하는 경우가 생깁니다. 

### 케이스 분리

각 케이스를 분리할 수 있는지 고민합니다. 

예를 들어 6개의 주사위를 두명이 나눠서 굴리고 그 합을 비교하는 경우라면

단순히 계산해보면 6^6이지만 각자가 굴릴 수 있는 주사위는 3개씩입니다. 

따라서 개인단위로는 6^3이고, 여기에 이분탐색으로 결과를 비교할 수 있습니다. 

대표적인 문제가 카카오 코테의 [주사위 고르기 문제](https://school.programmers.co.kr/learn/courses/30/lessons/258709) 문제입니다. 
 

### DFS 상태 분리

DFS로 문제를 풀 때는 그 경로만의 unique한 상태를 사용합니다. 

즉, 내부 프로퍼티로 상태를 관리할게 아니라 모든 걸 Parameter로 넘겨주어야합니다. 

## Dynamic programming 

DP는 다음 상황에 사용할 수 있습니다.

1. 분할정복처럼, 문제가 부분으로 나누어지면서 중복 계산이 필요해질 때 
2. 배열처럼 특정 순서가 있는 문제를 Step by Step으로 순회하면서 이전 계산 결과가 필요한 경우. 
3. 매번 최적의 결과를 도출하는게 아니고, 최종 결과가 최적일 경우. DFS+BFS를 활용하면서 시간복잡도를 줄일 수 있다.

### Tip 

Memoization을 관리하는 방법은 보통 정해져 있습니다.

1. 현재 값과 이전 배열의 값(혹은 순회 순서상 이전의 값) 중에서 필요한 값을 택한다.

2. 새로 만들어진 값과 기존의 값 중 필요한 값을 택한다.
